# cython: profile=True
#
#
# Web Lab model {{model_name}}
#
# Generated by {{generator_name}} on {{generation_date}}
#
#
#
cimport fc.sundials.sundials as Sundials

cimport libc.math as math
cimport numpy as np

import numpy as np
import os
import shutil
import sys

import fc.simulations.model as Model
import fc.utility.environment as Env
import fc.language.values as V
from fc.sundials.solver cimport CvodeSolver
from fc.utility.error_handling import ProtocolError


cdef int _EvaluateRhs(Sundials.realtype {{ free_variable }},
                      Sundials.N_Vector y,
                      Sundials.N_Vector ydot,
                      void* user_data):
    """
    Cython wrapper around a model RHS that uses numpy, for calling by CVODE.

    See :meth:`fc.sundials.solver._EvaluateRhs()`.
    """
    # We passed the Python model object in as CVODE user data; get it back as an object
    model = <object>user_data
    cdef np.ndarray[Sundials.realtype, ndim=1] parameters = <np.ndarray>model.parameters

    # Unpack state variables
    {%- for state in states %}
    cdef double {{state.var_name}} = (<Sundials.N_VectorContent_Serial>y.content).data[{{state.index}}]
    {%- endfor %}

    # Mathematics
    {%- for eq in rhs_equations %}
    {%- if eq.parameter_index is none %}
    cdef double {{ eq.lhs }} = {{ eq.rhs }}
    {%- else %}
    cdef double {{ eq.lhs }} = parameters[{{ eq.parameter_index }}]
    {%- endif %}
    {%- endfor %}

    # Pack state variable derivatives
    {%- for state in states %}
    (<Sundials.N_VectorContent_Serial>ydot.content).data[{{state.index}}] = {{state.deriv_name}}
    {%- endfor %}


cdef class {{ class_name }}(CvodeSolver):

    # The name of the free variable, for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public char* freeVariableName

    # The value of the free variable
    # From: fc.simulations.AbstractOdeModel
    cdef public double freeVariable

    # A mapping from variable name to index within the state variable vector,
    # for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object stateVarMap

    # A numpy array containing initial values for the state variables
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray initialState

    # A mapping from parameter name to index within the parameters vector, for
    # use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object parameterMap

    # A numpy array containing model parameter values
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray parameters

    # An ordered list of the names of the model outputs, as they will be
    # returned by GetOutputs
    # From: fc.simulations.AbstractOdeModel
    cdef public object outputNames

    # Mapping from names to saved model states.
    # From: fc.simulations.AbstractOdeModel
    cdef public object savedStates

    # Maps oxmeta variable names to model variables (outputs, states,
    # parameters, or the free variable).
    # From: fc.simulations.AbstractOdeModel
    # See: fc.utility.environment.ModelWrapperEnvironment
    cdef public object env

    # True if the solver needs to be reset due to a model change made in the
    # ModelWrapperEnvironment.
    # From: fc.simulations.AbstractOdeModel
    cdef public bint dirty

    # Where to write protocol outputs, error logs, etc.
    # From: fc.simulations.AbstractModel
    cdef public char* outputPath

    # Level of indentation to use for progress output.
    # From: fc.simulations.AbstractModel
    cdef public object indentLevel

    # Link to generated module.
    # Set in: fc.utility.protocol.Protocol
    # Note: Nobody seems to ever access this variable. Seems this is just to
    # prevent garbage collection.
    cdef public object _module

    # TODO What's this?
    # Set in: fc.simulations.Sim.AbstractSimulation
    cdef public object simEnv

    # Cached list of output values (single values or vectors e.g. the state) to
    # avoid recreating a list every time output is returned.
    cdef public object _outputs

    # Seems to be unused at the moment
    #cdef Sundials.N_Vector _parameters

    def __init__(self):
        self.freeVariableName = "time"
        self.freeVariable = 0.0

        # State values
        self.state = np.zeros({{ n_states }})

        # Mapping from oxmeta names to state indices; only for states that have
        # a variable name.
        self.stateVarMap = {}
        {%- for state in states %}
        {%- endfor %}

        # Initial state
        self.initialState = np.zeros({{ n_states }})
        {%- for state in states %}
        self.initialState[{{ state.index }}] = {{ state.initial_value }}
        {%- endfor %}

        # Mapping of parameter oxmeta names to parameter array indices
        self.parameterMap = {}
        {%- for parameter in parameters %}
        self.parameterMap['{{ parameter.cmeta_id }}'] = {{ parameter.index }}
        {%- endfor %}

        # Initial parameter values
        self.parameters = np.zeros({{ n_parameters }})
        {%- for parameter in parameters %}
        self.parameters[{{ parameter.index }}] = {{ parameter.initial_value }}
        {%- endfor %}

        # Oxmeta names of output variables
        self.outputNames = []
        {%- for output in outputs %}
        self.outputNames.append('{{ output.cmeta_id }}')
        {%- endfor %}

        # Create and cache list of arrays, to avoid constant list/array
        # creation
        self._outputs = []
        {%- for output in outputs %}
        self._outputs.append(np.array(0.0))
        {%- endfor %}
        # TODO Handle vector outputs

        self.state = self.initialState.copy()
        self.savedStates = {}
        self.dirty = False
        self.indentLevel = 0
        self.AssociateWithModel(self)
        #self._parameters = Sundials.N_VMake_Serial(
        #    len(self.parameters),
        #    <Sundials.realtype*>(<np.ndarray>self.parameters).data
        #)
        self.env = Env.ModelWrapperEnvironment(self)

    #def __dealloc__(self):
    #    if self._parameters != NULL:
    #        Sundials.N_VDestroy_Serial(self._parameters)

    def GetEnvironmentMap(self):
        """
        Get a map from ontology prefix to the environment containing model
        variables annotated with that ontology.

        See :meth:`fc.simulations.AbstractOdeModel.GetEnvironmentMap()`.
        """
        # TODO Some part of this might need to be generated
        return {
            'pycml': self.env,
            'cmeta': self.env,
            'cg': self.env,
            'csub': self.env,
            'cs': self.env,
            'oxmeta': self.env,
            'lut': self.env,
            'proto': self.env,
            'None': self.env,
            'bqs': self.env,
            'pe': self.env,
            'dcterms': self.env,
            'xml': self.env,
            'dc': self.env,
            'bqbiol': self.env,
            'cml': self.env,
            'solver': self.env,
            'doc': self.env,
            'm': self.env,
            'rdf': self.env,
            'cellml': self.env,
            'vCard': self.env,
        }

    cpdef GetOutputs(self):
        """
        Return a list of the model's outputs at its current state.

        NB: this should return a Python list containing the model outputs as
        numpy arrays, not subclasses of V.AbstractValue.
        The order of outputs in this list must match self.outputNames, a list
        of the output names, which must be set by subclass constructors.

        See :meth:`fc.simulations.AbstractModel.getOutputs()`.
        """

        # Get parameters as sundials realtype numpy array
        cdef np.ndarray[Sundials.realtype, ndim=1] parameters = self.parameters

        # Get current free variable
        cdef double {{ free_variable }} = self.freeVariable

        # Unpack state variables
        {%- for state in states %}
        cdef double {{state.var_name}} = (<Sundials.N_VectorContent_Serial>y.content).data[{{state.index}}]
        {%- endfor %}

        # Mathematics
        {%- for eq in output_equations %}
        {%- if eq.parameter_index is none %}
        cdef double {{ eq.lhs }} = {{ eq.rhs }}
        {%- else %}
        cdef double {{ eq.lhs }} = parameters[{{ eq.parameter_index }}]
        {%- endif %}
        {%- endfor %}

        # Update output vector and return
        outputs = self._outputs
        {%- for output in outputs %}
        {%- if output.parameter_index is none %}
        outputs[{{ output.index }}][()] = {{ output.var_name }}
        {%- else %}
        outputs[{{ output.index }}][()] = parameters[{{ output.parameter_index }}]
        {%- endif %}
        {%- endfor %}
        return outputs

    cpdef ResetState(self, name=None):
        """
        Reset the model to the given named saved state, or to initial
        conditions if no name given.

        See :meth:`fc.simulations.AbstractOdeModel.ResetState()`.
        """
        if name is None:
            CvodeSolver.ResetSolver(self, self.initialState)
        else:
            CvodeSolver.ResetSolver(self, self.savedStates[name])

    def SaveState(self, name):
        """
        Save a copy of the current model state associated with the given name,
        to be restored using :meth:`ResetState()`.

        See :meth:`fc.simulations.AbstractOdeModel.SaveState()`.
        """
        self.savedStates[name] = self.state.copy()

    cpdef SetFreeVariable(self, double t):
        """
        Set the value of the free variable (typically time), but retain the
        model's current state.

        See :meth:`fc.simulations.AbstractOdeModel.SetFreeVariable()`.
        """
        self.freeVariable = t
        CvodeSolver.SetFreeVariable(self, t)

    def SetIndentLevel(self, indentLevel):
        """
        Set the level of indentation to use for progress output.

        See :meth:`fc.simulations.AbstractModel.setIndentLevel()`.
        """
        self.indentLevel = indentLevel

    def SetOutputFolder(self, path):
        # TODO This is undocumented in fc
        if os.path.isdir(path) and path.startswith('/tmp'):
            shutil.rmtree(path)
        os.mkdir(path)
        self.outputPath = path

    def SetRhsWrapper(self):
        flag = Sundials.CVodeInit(
            self.cvode_mem, _EvaluateRhs, 0.0, self._state)
        self.CheckFlag(flag, 'CVodeInit')

    def SetSolver(self, solver):
        """
        Specify the ODE solver to use for this model.

        See :meth:`fc.simulations.AbstractOdeModel.SetSolver()`.
        """
        # TODO Update this (and rest of fc) to Python3
        # TODO Use logging here, or raise an exception
        print >>sys.stderr, '  ' * self.indentLevel, 'SetSolver: Models implemented using Cython contain a built-in ODE solver, so ignoring setting.'

