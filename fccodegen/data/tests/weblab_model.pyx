# cython: profile=True
#
#
# Web Lab model hodgkin_huxley_squid_axon_model_1952_modified
#
# Generated by fccodegen 0.0.1 on 2018-11-30 13:40:52
#
#
#
cimport fc.sundials.sundials as Sundials

cimport libc.math as math
cimport numpy as np

import numpy as np
import os
import shutil
import sys

import fc.simulations.model as Model
import fc.utility.environment as Env
import fc.language.values as V
from fc.sundials.solver cimport CvodeSolver
from fc.utility.error_handling import ProtocolError


cdef int _EvaluateRhs(Sundials.realtype var_environment__time, # TODO Replace name
                      Sundials.N_Vector y,
                      Sundials.N_Vector ydot,
                      void* user_data):
    """
    Cython wrapper around a model RHS that uses numpy, for calling by CVODE.

    See :meth:`fc.sundials.solver._EvaluateRhs()`.
    """
    # Cast user data point from sundials back to numpy parameter vector.
    model = <object>user_data
    # TODO Generate this
    cdef np.ndarray[Sundials.realtype, ndim=1] parameters = <np.ndarray>model.parameters

    # Unpack state variables
    cdef double var_V = (<Sundials.N_VectorContent_Serial>y.content).data[0]
    cdef double var_m = (<Sundials.N_VectorContent_Serial>y.content).data[1]
    cdef double var_h = (<Sundials.N_VectorContent_Serial>y.content).data[2]
    cdef double var_n = (<Sundials.N_VectorContent_Serial>y.content).data[3]

    # Mathematics
    # TODO Ignore free variable
    # TODO replace RHS by parameters if required (or skip over parameters)
    cdef double var_g_L = 0.3
    cdef double var_Cm = 1
    cdef double var_E_R = -75
    cdef double var_E_L = 10.613 + var_E_R
    cdef double var_i_L = (-var_E_L + var_V) * var_g_L
    cdef double var_stim_amplitude = -20
    cdef double var_stim_duration = 0.5
    cdef double var_stim_end = 10000
    cdef double var_stim_period = 1000
    cdef double var_stim_start = 10
    cdef double var_i_Stim = ((var_stim_amplitude) if (var_time >= var_stim_start and var_time <= var_stim_end and -var_stim_start - var_stim_period * math.floor((-var_stim_start + var_time) / var_stim_period) + var_time <= var_stim_duration) else (0.0))
    cdef double var_E_K = -12.0 + var_E_R
    cdef double var_g_K = 36
    cdef double var_alpha_n = -0.01 * (65.0 + var_V) / (-1.0 + 0.0015034391929775724 * math.exp(-0.1 * var_V))
    cdef double var_beta_n = 0.31919868225786585 * math.exp(0.0125 * var_V)
    cdef double d_dt_n = (1.0 - var_n) * var_alpha_n - var_beta_n * var_n
    cdef double var_i_K = var_n**4.0 * (-var_E_K + var_V) * var_g_K
    cdef double var_E_Na = 115.0 + var_E_R
    cdef double var_g_Na = 120
    cdef double var_alpha_h = 0.0016462422099206377 * math.exp(-0.05 * var_V)
    cdef double var_beta_h = 1.0 / (1.0 + 0.011108996538242306 * math.exp(-0.1 * var_V))
    cdef double d_dt_h = (1.0 - var_h) * var_alpha_h - var_beta_h * var_h
    cdef double var_alpha_m = -0.1 * (50.0 + var_V) / (-1.0 + 0.006737946999085467 * math.exp(-0.1 * var_V))
    cdef double var_beta_m = 0.06201541439603731 * math.exp(-0.05555555555555555 * var_V)
    cdef double d_dt_m = (1.0 - var_m) * var_alpha_m - var_beta_m * var_m
    cdef double var_i_Na = var_m**3.0 * (-var_E_Na + var_V) * var_g_Na * var_h
    cdef double d_dt_V = (-var_i_L - var_i_Stim - var_i_K - var_i_Na) / var_Cm

    # Pack state variable derivatives
    (<Sundials.N_VectorContent_Serial>ydot.content).data[0] = d_dt_V
    (<Sundials.N_VectorContent_Serial>ydot.content).data[1] = d_dt_m
    (<Sundials.N_VectorContent_Serial>ydot.content).data[2] = d_dt_h
    (<Sundials.N_VectorContent_Serial>ydot.content).data[3] = d_dt_n


cdef class GeneratedModel_Proto_tmpHzG5bQ(CvodeSolver): # TODO Generate name

    # The name of the free variable, for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public char* freeVariableName

    # The value of the free variable
    # From: fc.simulations.AbstractOdeModel
    cdef public double freeVariable

    # A mapping from variable name to index within the state variable vector,
    # for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object stateVarMap

    # A numpy array containing initial values for the state variables
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray initialState

    # A mapping from parameter name to index within the parameters vector, for
    # use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object parameterMap

    # A numpy array containing model parameter values
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray parameters

    # An ordered list of the names of the model outputs, as they will be
    # returned by GetOutputs
    # From: fc.simulations.AbstractOdeModel
    cdef public object outputNames

    # Mapping from names to saved model states.
    # From: fc.simulations.AbstractOdeModel
    cdef public object savedStates

    # An instance of fc.utility.environment.ModelWrapperEnvironment
    # TODO: What's this?
    # From: fc.simulations.AbstractOdeModel
    cdef public object env

    # True if the solver needs to be reset due to a model change.
    # TODO This is only ever set via the "environment". Not sure why.
    # From: fc.simulations.AbstractOdeModel
    cdef public bint dirty

    # TODO Not documented in AbstractModel
    # From: fc.simulations.AbstractModel
    cdef public char* outputPath

    # Level of indentation to use for progress output.
    # From: fc.simulations.AbstractModel
    cdef public object indentLevel

    # Link to generated module.
    # Set in: fc.utility.protocol.Protocol
    # TODO: Nobody seems to ever access this variable. Is it just to prevent
    # garbage collection?
    cdef public object _module

    # TODO What's this?
    # Set in: fc.simulations.Sim.AbstractSimulation
    cdef public object simEnv

    # Cached list of output values (single values or vectors e.g. the state) to
    # avoid recreating a list every time output is returned.
    cdef public object _outputs

    # Seems to be unused at the moment
    #cdef Sundials.N_Vector _parameters

    def __init__(self):
        self.freeVariableName = "time"
        self.freeVariable = 0.0

        # TODO Generate this
        self.state = np.zeros(2)
        self.stateVarMap = {}

        # TODO Generate this
        self.initialState = np.zeros(2)
        self.initialState[0] = 0 # (c,rapid_time_dependent_potassium_current_Xr1_gate__Xr1) dimensionless
        self.initialState[1] = 1 # (c,rapid_time_dependent_potassium_current_Xr2_gate__Xr2) dimensionless

        # TODO Generate this
        self.parameterMap = {}
        self.parameters = np.zeros(4)
        self.parameterMap["cytosolic_potassium_concentration"] = 0
        self.parameters[0] = 138.3 # (c,potassium_dynamics__K_i) millimolar
        self.parameterMap["cytosolic_sodium_concentration"] = 1
        self.parameters[1] = 11.6 # (c,sodium_dynamics__Na_i) millimolar
        self.parameterMap["extracellular_potassium_concentration"] = 2
        self.parameters[2] = 5.4 # (c,potassium_dynamics__K_o) millimolar
        self.parameterMap["membrane_voltage"] = 3
        self.parameters[3] = 0.0 # (c,membrane__V) millivolt

        # TODO Generate this
        self.outputNames = []
        outputs = self._outputs = []
        self.outputNames.append("cytosolic_potassium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("cytosolic_sodium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("extracellular_potassium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("membrane_rapid_delayed_rectifier_potassium_current")
        outputs.append(np.array(0.0))
        self.outputNames.append("membrane_voltage")
        outputs.append(np.array(0.0))
        self.outputNames.append("time")
        outputs.append(np.array(0.0))

        self.state = self.initialState.copy()
        self.savedStates = {}
        self.dirty = False
        self.indentLevel = 0
        self.AssociateWithModel(self)
        #self._parameters = Sundials.N_VMake_Serial(
        #    len(self.parameters),
        #    <Sundials.realtype*>(<np.ndarray>self.parameters).data
        #)
        self.env = Env.ModelWrapperEnvironment(self)

    #def __dealloc__(self):
    #    if self._parameters != NULL:
    #        Sundials.N_VDestroy_Serial(self._parameters)

    def GetEnvironmentMap(self):
        """
        Get a map from ontology prefix to the environment containing model
        variables annotated with that ontology.

        See :meth:`fc.simulations.AbstractOdeModel.GetEnvironmentMap()`.
        """
        # TODO Some part of this might need to be generated
        return {
            'pycml': self.env,
            'cmeta': self.env,
            'cg': self.env,
            'csub': self.env,
            'cs': self.env,
            'oxmeta': self.env,
            'lut': self.env,
            'proto': self.env,
            'None': self.env,
            'bqs': self.env,
            'pe': self.env,
            'dcterms': self.env,
            'xml': self.env,
            'dc': self.env,
            'bqbiol': self.env,
            'cml': self.env,
            'solver': self.env,
            'doc': self.env,
            'm': self.env,
            'rdf': self.env,
            'cellml': self.env,
            'vCard': self.env,
        }

    cpdef GetOutputs(self):
        """
        Return a list of the model's outputs at its current state.

        NB: this should return a Python list containing the model outputs as
        numpy arrays, not subclasses of V.AbstractValue.
        The order of outputs in this list must match self.outputNames, a list
        of the output names, which must be set by subclass constructors.

        See :meth:`fc.simulations.AbstractModel.getOutputs()`.
        """
        # TODO Generate this method

        cdef np.ndarray[Sundials.realtype, ndim=1] parameters = self.parameters
        cdef double var_environment__time = self.freeVariable

        # State variables
        cdef double var_rapid_time_dependent_potassium_current_Xr1_gate__Xr1 = self.state[0]
        cdef double var_rapid_time_dependent_potassium_current_Xr2_gate__Xr2 = self.state[1]

        # Compute outputs
        cdef double var_reversal_potentials__E_K = 26.713760659695648 * math.log(parameters[2] / parameters[0]) # millivolt
        cdef double var_rapid_time_dependent_potassium_current__g_Kr = 0.096000000000000002 # nanoS_per_picoF
        cdef double var_protocol__rapid_time_dependent_potassium_current__i_Kr = (var_rapid_time_dependent_potassium_current__g_Kr * math.sqrt(parameters[2] * 0.18518518518518517) * var_rapid_time_dependent_potassium_current_Xr1_gate__Xr1 * var_rapid_time_dependent_potassium_current_Xr2_gate__Xr2 * (parameters[3] - var_reversal_potentials__E_K)) * 1.0 # uA_per_cm2

        # Update output vector and return
        outputs = self._outputs
        outputs[0][()] = parameters[0]
        outputs[1][()] = parameters[1]
        outputs[2][()] = parameters[2]
        outputs[3][()] = var_protocol__rapid_time_dependent_potassium_current__i_Kr
        outputs[4][()] = parameters[3]
        outputs[5][()] = var_environment__time
        return outputs

    cpdef ResetState(self, name=None):
        """
        Reset the model to the given named saved state, or to initial
        conditions if no name given.

        See :meth:`fc.simulations.AbstractOdeModel.ResetState()`.
        """
        if name is None:
            CvodeSolver.ResetSolver(self, self.initialState)
        else:
            CvodeSolver.ResetSolver(self, self.savedStates[name])

    def SaveState(self, name):
        """
        Save a copy of the current model state associated with the given name,
        to be restored using :meth:`ResetState()`.

        See :meth:`fc.simulations.AbstractOdeModel.SaveState()`.
        """
        self.savedStates[name] = self.state.copy()

    cpdef SetFreeVariable(self, double t):
        """
        Set the value of the free variable (typically time), but retain the
        model's current state.

        See :meth:`fc.simulations.AbstractOdeModel.SetFreeVariable()`.
        """
        self.freeVariable = t
        CvodeSolver.SetFreeVariable(self, t)

    def SetIndentLevel(self, indentLevel):
        """
        Set the level of indentation to use for progress output.

        See :meth:`fc.simulations.AbstractModel.setIndentLevel()`.
        """
        self.indentLevel = indentLevel

    def SetOutputFolder(self, path):
        # TODO This is undocumented in fc
        if os.path.isdir(path) and path.startswith('/tmp'):
            shutil.rmtree(path)
        os.mkdir(path)
        self.outputPath = path

    def SetRhsWrapper(self):
        flag = Sundials.CVodeInit(
            self.cvode_mem, _EvaluateRhs, 0.0, self._state)
        self.CheckFlag(flag, "CVodeInit")

    def SetSolver(self, solver):
        """
        Specify the ODE solver to use for this model.

        See :meth:`fc.simulations.AbstractOdeModel.SetSolver()`.
        """
        # TODO Should this be python 3 syntax? Or is this special Cython
        # syntax?
        # TODO Can we use logging here instead? Or an exception?
        print >>sys.stderr, "  " * self.indentLevel, "SetSolver: Models implemented using Cython contain a built-in ODE solver, so ignoring setting."
