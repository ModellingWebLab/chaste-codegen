# cython: profile=True
#
#
# Web Lab model hodgkin_huxley_squid_axon_model_1952_modified
#
# Generated by Michael
#
#
#
cimport fc.sundials.sundials as Sundials
cimport libc.math as math
cimport numpy as np

import fc.simulations.model as Model
import fc.utility.environment as Env
import fc.language.values as V
from fc.sundials.solver cimport CvodeSolver
from fc.utility.error_handling import ProtocolError
import numpy as np
import os
import shutil
import sys


cdef int _EvaluateRhs(Sundials.realtype var_environment__time, Sundials.N_Vector y, Sundials.N_Vector ydot, void* user_data):
    """
    Main model method: evaluates the model's RHS.
    """
    #TODO: What's this?
    model = <object>user_data
    cdef np.ndarray[Sundials.realtype, ndim=1] parameters = <np.ndarray>model.parameters

    # Unpack state variables
    cdef double var_V = (<Sundials.N_VectorContent_Serial>y.content).data[0]
    cdef double var_m = (<Sundials.N_VectorContent_Serial>y.content).data[1]
    cdef double var_h = (<Sundials.N_VectorContent_Serial>y.content).data[2]
    cdef double var_n = (<Sundials.N_VectorContent_Serial>y.content).data[3]

    # Mathematics
    cdef double var_g_L = 0.3
    cdef double var_Cm = 1
    cdef double var_E_R = -75
    cdef double var_E_L = 10.613 + var_E_R
    cdef double var_i_L = (-var_E_L + var_V) * var_g_L
    cdef double var_stim_amplitude = -20
    cdef double var_stim_duration = 0.5
    cdef double var_stim_end = 10000
    cdef double var_stim_period = 1000
    cdef double var_stim_start = 10
    cdef double var_i_Stim = ((var_stim_amplitude) if (var_time >= var_stim_start and var_time <= var_stim_end and -var_stim_start - var_stim_period * math.floor((-var_stim_start + var_time) / var_stim_period) + var_time <= var_stim_duration) else (0.0))
    cdef double var_E_K = -12.0 + var_E_R
    cdef double var_g_K = 36
    cdef double var_alpha_n = -0.01 * (65.0 + var_V) / (-1.0 + 0.0015034391929775724 * math.exp(-0.1 * var_V))
    cdef double var_beta_n = 0.31919868225786585 * math.exp(0.0125 * var_V)
    cdef double d_dt_n = (1.0 - var_n) * var_alpha_n - var_beta_n * var_n
    cdef double var_i_K = var_n**4.0 * (-var_E_K + var_V) * var_g_K
    cdef double var_E_Na = 115.0 + var_E_R
    cdef double var_g_Na = 120
    cdef double var_alpha_h = 0.0016462422099206377 * math.exp(-0.05 * var_V)
    cdef double var_beta_h = 1.0 / (1.0 + 0.011108996538242306 * math.exp(-0.1 * var_V))
    cdef double d_dt_h = (1.0 - var_h) * var_alpha_h - var_beta_h * var_h
    cdef double var_alpha_m = -0.1 * (50.0 + var_V) / (-1.0 + 0.006737946999085467 * math.exp(-0.1 * var_V))
    cdef double var_beta_m = 0.06201541439603731 * math.exp(-0.05555555555555555 * var_V)
    cdef double d_dt_m = (1.0 - var_m) * var_alpha_m - var_beta_m * var_m
    cdef double var_i_Na = var_m**3.0 * (-var_E_Na + var_V) * var_g_Na * var_h
    cdef double d_dt_V = (-var_i_L - var_i_Stim - var_i_K - var_i_Na) / var_Cm

    # Pack state variable derivatives
    (<Sundials.N_VectorContent_Serial>ydot.content).data[0] = d_dt_V
    (<Sundials.N_VectorContent_Serial>ydot.content).data[1] = d_dt_m
    (<Sundials.N_VectorContent_Serial>ydot.content).data[2] = d_dt_h
    (<Sundials.N_VectorContent_Serial>ydot.content).data[3] = d_dt_n


cdef class GeneratedModel_Proto_tmpHzG5bQ(CvodeSolver):
    cdef public char* freeVariableName
    cdef public double freeVariable
    cdef public object stateVarMap
    cdef public np.ndarray initialState
    cdef public object parameterMap
    cdef public np.ndarray parameters
    cdef public object outputNames

    cdef public object savedStates
    cdef public object env
    cdef public bint dirty
    cdef public char* outputPath
    cdef public object indentLevel

    cdef public object _module
    cdef public object simEnv

    cdef Sundials.N_Vector _parameters
    cdef public object _outputs

    def __init__(self):
        self.freeVariableName = "time"
        self.freeVariable = 0.0
        self.state = np.zeros(2)
        self.stateVarMap = {}
        self.initialState = np.zeros(2)
        self.initialState[0] = 0 # (c,rapid_time_dependent_potassium_current_Xr1_gate__Xr1) dimensionless
        self.initialState[1] = 1 # (c,rapid_time_dependent_potassium_current_Xr2_gate__Xr2) dimensionless

        self.parameterMap = {}
        self.parameters = np.zeros(4)
        self.parameterMap["cytosolic_potassium_concentration"] = 0
        self.parameters[0] = 138.3 # (c,potassium_dynamics__K_i) millimolar
        self.parameterMap["cytosolic_sodium_concentration"] = 1
        self.parameters[1] = 11.6 # (c,sodium_dynamics__Na_i) millimolar
        self.parameterMap["extracellular_potassium_concentration"] = 2
        self.parameters[2] = 5.4 # (c,potassium_dynamics__K_o) millimolar
        self.parameterMap["membrane_voltage"] = 3
        self.parameters[3] = 0.0 # (c,membrane__V) millivolt

        self.outputNames = []
        outputs = self._outputs = []
        self.outputNames.append("cytosolic_potassium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("cytosolic_sodium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("extracellular_potassium_concentration")
        outputs.append(np.array(0.0))
        self.outputNames.append("membrane_rapid_delayed_rectifier_potassium_current")
        outputs.append(np.array(0.0))
        self.outputNames.append("membrane_voltage")
        outputs.append(np.array(0.0))
        self.outputNames.append("time")
        outputs.append(np.array(0.0))

        self.state = self.initialState.copy()
        self.savedStates = {}
        self.dirty = False
        self.indentLevel = 0
        self.AssociateWithModel(self)
        self._parameters = Sundials.N_VMake_Serial(len(self.parameters), <Sundials.realtype*>(<np.ndarray>self.parameters).data)
        self.env = Env.ModelWrapperEnvironment(self)

    def SetRhsWrapper(self):
        flag = Sundials.CVodeInit(self.cvode_mem, _EvaluateRhs, 0.0, self._state)
        self.CheckFlag(flag, "CVodeInit")

    def __dealloc__(self):
        if self._parameters != NULL:
            Sundials.N_VDestroy_Serial(self._parameters)

    def SetOutputFolder(self, path):
        if os.path.isdir(path) and path.startswith('/tmp'):
            shutil.rmtree(path)
        os.mkdir(path)
        self.outputPath = path

    def SetIndentLevel(self, indentLevel):
        self.indentLevel = indentLevel

    def SetSolver(self, solver):
        print >>sys.stderr, "  " * self.indentLevel, "SetSolver: Models implemented using Cython contain a built-in ODE solver, so ignoring setting."

    def GetEnvironmentMap(self):
        return {'pycml': self.env, 'cmeta': self.env, 'cg': self.env, 'csub': self.env, 'cs': self.env, 'oxmeta': self.env, 'lut': self.env, 'proto': self.env, 'None': self.env, 'bqs': self.env, 'pe': self.env, 'dcterms': self.env, 'xml': self.env, 'dc': self.env, 'bqbiol': self.env, 'cml': self.env, 'solver': self.env, 'doc': self.env, 'm': self.env, 'rdf': self.env, 'cellml': self.env, 'vCard': self.env}

    cpdef SetFreeVariable(self, double t):
        self.freeVariable = t
        CvodeSolver.SetFreeVariable(self, t)

    def SaveState(self, name):
        self.savedStates[name] = self.state.copy()

    cpdef ResetState(self, name=None):
        if name is None:
            CvodeSolver.ResetSolver(self, self.initialState)
        else:
            CvodeSolver.ResetSolver(self, self.savedStates[name])

    cpdef GetOutputs(self):
        cdef np.ndarray[Sundials.realtype, ndim=1] parameters = self.parameters
        cdef double var_environment__time = self.freeVariable
        # State variables
        cdef double var_rapid_time_dependent_potassium_current_Xr1_gate__Xr1 = self.state[0]
        cdef double var_rapid_time_dependent_potassium_current_Xr2_gate__Xr2 = self.state[1]

        # Mathematics computing outputs of interest
        cdef double var_reversal_potentials__E_K = 26.713760659695648 * math.log(parameters[2] / parameters[0]) # millivolt
        cdef double var_rapid_time_dependent_potassium_current__g_Kr = 0.096000000000000002 # nanoS_per_picoF
        cdef double var_protocol__rapid_time_dependent_potassium_current__i_Kr = (var_rapid_time_dependent_potassium_current__g_Kr * math.sqrt(parameters[2] * 0.18518518518518517) * var_rapid_time_dependent_potassium_current_Xr1_gate__Xr1 * var_rapid_time_dependent_potassium_current_Xr2_gate__Xr2 * (parameters[3] - var_reversal_potentials__E_K)) * 1.0 # uA_per_cm2

        outputs = self._outputs
        outputs[0][()] = parameters[0]
        outputs[1][()] = parameters[1]
        outputs[2][()] = parameters[2]
        outputs[3][()] = var_protocol__rapid_time_dependent_potassium_current__i_Kr
        outputs[4][()] = parameters[3]
        outputs[5][()] = var_environment__time
        return outputs

