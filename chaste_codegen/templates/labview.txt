//===========================================================================
// This source file was generated from CellML by chaste_codegen version {{converter_version}}
//
// Model: {{model_name}}
//
// Processed by chaste_codegen: https://github.com/ModellingWebLab/chaste-codegen
//     (translator: chaste_codegen, model type: {{model_type}})
// on {{generation_date}}
//
// <autogenerated>
//===========================================================================

//---------------------------------------------------------------------------
// Setup & input
//---------------------------------------------------------------------------

float64 Ynew[{{state_vars | length +1}}];
float64 dY[{{state_vars | length +1}}];
float64 Vmem;
float64 time;

//---------------------------------------------------------------------------
// State Variables
//---------------------------------------------------------------------------
{% for state_var in state_vars %}
// {{loop.index0}}: {{state_var.var}} (units: {{state_var.units}}, initial value: {{state_var.initial_value}}, component: {{components[loop.index0]}})
{%- endfor %}
// {{state_vars|length}}: {{free_variable.name}} ({{free_variable.units}})

//---------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------
{% for param in modifiable_parameters %}
float64 {{param.comment_name}} = {{param.initial_value}}; // {{param.units}} (in {{param.component}}){%- endfor %}

{% for deriv in derivative_alpha_beta_eqs %}
{%- if deriv.is_constant%}float64 {{deriv.lhs}} = {{deriv.rhs}}; // {{deriv.units}} (in {{deriv.component}})
{% endif %}{%- endfor %}
//------------------------------------------------------------------------------
// Computed variables
//------------------------------------------------------------------------------

{% for deriv in derivative_alpha_beta_eqs %}
{%- if not deriv.is_constant and not deriv.lhs_is_sv%}float64 {{deriv.lhs}}; // {{deriv.units}} (in {{deriv.component}})
{% endif %}{%- endfor %}

//---------------------------------------------------------------------------
// Computation
//---------------------------------------------------------------------------
{% for deriv in derivative_alpha_beta_eqs %}
{%-if not deriv.is_constant%}
{%- if deriv.is_piecewise%}
{%- for expr_conds in deriv.pw_expr_conds %}
{% if expr_conds[1] == 'true' or loop.index0 != 0%}else {% endif %}{% if expr_conds[1] != 'true'%}if ({{expr_conds[1]}}){%- endif %}
    {{deriv.lhs}} = {{expr_conds[0]}}
{%- endfor %}
{% else %}
{{deriv.lhs}} = {{deriv.rhs}}; // {{deriv.units}}
{%- endif %}
{%- endif %}
{%- endfor %}
//------------------------------------------------------------------------------
// Integration & Output
//------------------------------------------------------------------------------
// Rush-Larsen method

// get tau/inf or alpha/beta

{% for deriv in derivative_alpha_beta %}{% if deriv.type!='non_linear'%}float64 alphaOrTau_{{loop.index0}} = {{deriv.r_alpha_or_tau}};
float64 betaOrInf_{{loop.index0}} = {{deriv.r_beta_or_inf}};
{% endif %}{%- endfor %}
// gating variables: Exponential integration
{% for deriv in derivative_alpha_beta %}{%- if deriv.type=='inftau'%}
Ynew[{{loop.index0}}] = betaOrInf_{{loop.index0}} + (Y[{{loop.index0}}] - betaOrInf_{{loop.index0}})*exp(-dt/alphaOrTau_{{loop.index0}});
{%- elif deriv.type!='non_linear'%}
float64 tau_inv_{{loop.index0}} = alphaOrTau_{{loop.index0}} + betaOrInf_{{loop.index0}};
float64 y_inf_{{loop.index0}} = alphaOrTau_{{loop.index0}} / tau_inv_{{loop.index0}};
Ynew[{{loop.index0}}] = y_inf_{{loop.index0}} + (Y[{{loop.index0}}] - y_inf_{{loop.index0}})*exp(-dt*tau_inv_{{loop.index0}});
{%- endif %}
{%- endfor %}

// Remainder: Forward Euler
{% for deriv in derivative_alpha_beta %}
{%- if deriv.type=='non_linear'%}
Ynew[{{loop.index0}}] = Y[{{loop.index0}}] + dt * {{deriv.deriv}};{%- endif %}{%- endfor %}
Ynew[{{state_vars | length}}] = Y[{{state_vars | length}}] + dt;

Vmem = Ynew[0];
time = Ynew[{{state_vars | length}}];