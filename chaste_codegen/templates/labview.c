//===========================================================================
// This source file was generated from CellML by chaste_codegen version {{converter_version}}
//
// Model: {{model_name}}
//
// Processed by chaste_codegen: https://github.com/ModellingWebLab/chaste-codegen
//     (translator: chaste_codegen, model type: {{model_type}})
// on {{generation_date}}
//
// <autogenerated>
//===========================================================================


#include "{{file_name}}.h"

//------------------------------------------------------------------------------

#include <math.h>
#include <string.h>

//------------------------------------------------------------------------------
// State variables
//------------------------------------------------------------------------------

extern double Y[_NB_OF_STATE_VARIABLES_];
double dY[_NB_OF_STATE_VARIABLES_];
double Ynew[_NB_OF_STATE_VARIABLES_];

{%- for state_var in state_vars %}
// {{loop.index0}}: {{state_var.var}} (units: {{state_var.units}}, initial value: {{state_var.initial_value}}, component: {{components[loop.index0]}})
{%- endfor %}

double Vmem;
double time;

char YNames[_NB_OF_STATE_VARIABLES_][{{stat_var_name_max_length +1}}];
char YUnits[_NB_OF_STATE_VARIABLES_][{{unit_name_max_length +1}}];
char YComponents[_NB_OF_STATE_VARIABLES_][{{component_name_max_length +1 }}];

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
{% for param in modifiable_parameters %}
double {{param["comment_name"]}}; // {{param["units"]}} (in {{param["component"]}}){%- endfor %}

{% for deriv in y_derivative_equations %}
{%- if deriv.is_constant%}double {{deriv.lhs}}; // {{deriv.units}} (in {{deriv.component}})
{% endif %}{%- endfor %}
//------------------------------------------------------------------------------
// Computed variables
//------------------------------------------------------------------------------

{% for deriv in y_derivative_equations %}
{%- if not deriv.is_constant and not deriv.lhs_is_sv%}double {{deriv.lhs}}; // {{deriv.units}} (in {{deriv.component}})
{% endif %}{%- endfor %}

//------------------------------------------------------------------------------
// Initialisation
//------------------------------------------------------------------------------

void init()
{
    //---------------------------------------------------------------------------
    // State variables
    //---------------------------------------------------------------------------
{%for state_var in state_vars %}
    Y[{{loop.index0}}] = {{state_var.initial_value}}; // {{state_var.var}} ({{state_var.units}}) (in {{components[loop.index0]}})
{%- endfor %}
    Y[{{state_vars | length}}]; // ({{free_variable.var_name}}} (milliseconds)

{%for state_var in state_vars %}
    strcpy(YNames[{{loop.index0}}], "{{state_var.var}}");
{%- endfor %}
    strcpy(YNames[{{state_vars | length}}], "{{free_variable.var_name}}");

{%for state_var in state_vars %}
    strcpy(YUnits[{{loop.index0}}], "{{state_var.units}}");
{%- endfor %}
    strcpy(YUnits[{{state_vars | length}}], "milliseconds");

    //------------------------------------------------------------------------------
    // Constants
    //------------------------------------------------------------------------------
{% for param in modifiable_parameters %}
    {{param["comment_name"]}} = {{param["initial_value"]}};{%- endfor %}

{% for deriv in y_derivative_equations %}
{%- if deriv.is_constant%}    {{deriv.lhs}} = {{deriv.rhs}};
{% endif %}{%- endfor %}
}

    //---------------------------------------------------------------------------
    // Computation
    //---------------------------------------------------------------------------
void compute()
{
   // time: {{free_variable.var_name}} (millisecond)
{% for deriv in y_derivative_equations %}
{%- if not deriv.is_constant%}
{%- if deriv.is_piecewise%}
{%- for expr_conds in deriv.pw_expr_conds %}
    {% if expr_conds[1] == 'true' or loop.index0 != 0%}else {% endif %}{% if expr_conds[1] != 'true'%}if ({{expr_conds[1]}}){%- endif %}
        {{deriv.lhs}} = {{expr_conds[0]}}
{%- endfor %}
{% else %}
    {{deriv.lhs}} = {{deriv.rhs}};
{%- endif %}
{%- endif %}
{%- endfor %}
}

    //------------------------------------------------------------------------------
    // Integration & Output
    //------------------------------------------------------------------------------
    // Rush-Larsen method


// get tau/inf or alpha/beta
void computeTauInf()
  {% for deriv in derivative_alpha_beta %}{% if deriv.type!='non_linear'%}double alphaOrTau_{{loop.index0}} = {{deriv.r_alpha_or_tau}};
  double betaOrInf_{{loop.index0}} = {{deriv.r_beta_or_inf}};
  {% endif %}{%- endfor %}
  // gating variables: Exponential integration
  {% for deriv in derivative_alpha_beta %}{%- if deriv.type=='inftau'%}
  Ynew[{{loop.index0}}] = betaOrInf_{{loop.index0}} + (Y[{{loop.index0}}] - betaOrInf_{{loop.index0}})*exp(-dt/alphaOrTau_{{loop.index0}});
  {%- elif deriv.type!='non_linear'%}
  double tau_inv_{{loop.index0}} = alphaOrTau_{{loop.index0}} + betaOrInf_{{loop.index0}};
  double y_inf_{{loop.index0}} = alphaOrTau_{{loop.index0}} / tau_inv_{{loop.index0}};
  Ynew[{{loop.index0}}] = y_inf_{{loop.index0}} + (Y[{{loop.index0}}] - y_inf_{{loop.index0}})*exp(-dt*tau_inv_{{loop.index0}});
  {%- endif %}
  {%- endfor %}
}

// Remainder: Forward Euler
void computeRemainderForaredEuler(){
{% for deriv in derivative_alpha_beta %}
  {%- if deriv.type=='non_linear'%}
  Ynew[{{loop.index0}}] = Y[{{loop.index0}}] + dt * {{deriv.deriv}};{%- endif %}{%- endfor %}
  Ynew[{{state_vars | length}}] = Y[{{state_vars | length}}] + dt;
}

compute();
computeTauInf();
computeRemainderForaredEuler();


Vmem = Ynew[0];
time = Ynew[{{state_vars | length}}];



//==============================================================================
// End of file
//==============================================================================
