
    void {{class_name}}::ComputeOneStepExceptVoltage(double {{free_variable.var_name}})
    {
        {{vector_decl}} rY = rGetStateVariables();
        const double delta = 1e-8;

        {% for state_var in state_vars %}
        {%- if state_var.in_deriv_excl_voltage %}double {{ state_var.var }} = {% if loop.index0 == membrane_voltage_index %}(mSetVoltageDerivativeToZero ? this->mFixedVoltage : {{state_vec_ind_start}}{{loop.index0}}{{vec_ind_end}});{%- else %}{{state_vec_ind_start}}{{loop.index0}}{{vec_ind_end}};{%- endif %}
        // Units: {{state_var.units}}; Initial value: {{state_var.initial_value}}
        {% endif %}{%- endfor %}
        
        // Mathematics
        {%- for deriv in y_derivative_equations %}{% if deriv.in_eqs_excl_voltage %}
        {% if not deriv.is_voltage%}const double {% endif %}{{deriv.lhs}} = {{deriv.rhs}}; // {{deriv.units}}{%- endif %}
        {%- endfor %}

        {%- for deriv in y_derivatives %}
        {% if loop.index0 != membrane_voltage_index %}mEvalF[{{loop.index0}}] = {{deriv}};
        mPartialF[{{loop.index0}}] = EvaluatePartialDerivative{{loop.index0}}({{free_variable.var_name}}, rY, delta);{% endif %}{%- endfor %}

        {%- for deriv in y_derivatives %}
        {% if loop.index0 != membrane_voltage_index %}{
            if (fabs(mPartialF[{{loop.index0}}]) < delta){
                {{state_vec_ind_start}}{{loop.index0}}{{vec_ind_end}} += mDt*{{deriv}};
            }
            else
            {
                {{state_vec_ind_start}}{{loop.index0}}{{vec_ind_end}} += ({{deriv}}/mPartialF[{{loop.index0}}])*(exp(mPartialF[{{loop.index0}}]*mDt)-1.0);
            }
            
        }{% endif %}{%- endfor %}        
        
    }
   